"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api/botService.ts":
/*!*******************************!*\
  !*** ./lib/api/botService.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   executeSQL: function() { return /* binding */ executeSQL; },\n/* harmony export */   getBotResponse: function() { return /* binding */ getBotResponse; },\n/* harmony export */   parseQuery: function() { return /* binding */ parseQuery; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Bot service for handling AI responses with multiple chart types\nconst getBotResponse = async (message)=>{\n    const D1_URL = process.env.NEXT_PUBLIC_D1_API_URL || \"https://ai-engine-1.onrender.com\";\n    const D2_URL = process.env.NEXT_PUBLIC_D2_API_URL || \"http://31.220.72.148:3001\";\n    try {\n        // Step 1: Parse query\n        const d1Response = await parseQuery(message);\n        console.log(\"D1 Response:\", d1Response);\n        // Step 2: Run SQL\n        const d2DataResponse = await executeSQL(d1Response.sql);\n        console.log(\"D2 Data Response:\", d2DataResponse);\n        // Step 3: Format data for charts/maps/tables\n        let vizData = null;\n        if ([\n            \"chart\",\n            \"map\"\n        ].includes(d1Response.intent)) {\n            vizData = formatVizData(d2DataResponse.data, d1Response.intent);\n            console.log(\"Formatted Viz Data:\", vizData);\n        }\n        // Step 4: Return to UI\n        return {\n            id: Date.now(),\n            sender: \"bot\",\n            text: \"Here is the \".concat(d1Response.intent, ' for \"').concat(d1Response.query, '\"'),\n            type: d1Response.intent,\n            data: vizData,\n            rawData: d2DataResponse.data // for tables\n        };\n    } catch (err) {\n        console.error(\"Bot response error:\", err);\n        return getMockResponse(message);\n    }\n};\n// ---------- Format Chart Data Dynamically ----------\nconst formatVizData = (data, intent)=>{\n    if (!data || data.length === 0) return null;\n    // Detect chart type from intent\n    let chartType = \"line\";\n    if (intent.includes(\"bar\")) chartType = \"bar\";\n    else if (intent.includes(\"pie\")) chartType = \"pie\";\n    else if (intent.includes(\"map\") || intent.includes(\"heatmap\")) chartType = \"heatmap\";\n    else if (intent.includes(\"line\") || intent.includes(\"trend\")) chartType = \"line\";\n    // Extract labels (x-axis) & datasets (y-values)\n    const labels = data.map((row)=>row.year || row.category || \"Unknown\");\n    const keys = Object.keys(data[0]).filter((k)=>k !== \"year\" && k !== \"category\");\n    const datasets = keys.map((k)=>({\n            label: k,\n            data: data.map((row)=>Number(row[k]) || 0),\n            backgroundColor: chartType === \"pie\" ? [\n                \"rgba(255,99,132,0.6)\",\n                \"rgba(54,162,235,0.6)\",\n                \"rgba(255,206,86,0.6)\",\n                \"rgba(75,192,192,0.6)\"\n            ] : \"rgba(54,162,235,0.5)\",\n            borderColor: \"rgba(54,162,235,1)\",\n            fill: chartType !== \"line\"\n        }));\n    return {\n        type: chartType,\n        data: {\n            labels,\n            datasets\n        },\n        options: {\n            responsive: true,\n            plugins: {\n                legend: {\n                    position: \"top\"\n                },\n                title: {\n                    display: true,\n                    text: \"Groundwater Data Visualization\"\n                }\n            }\n        }\n    };\n};\n// ---------- Existing Functions ----------\nconst parseQuery = async (query)=>{\n    const D1_URL = process.env.NEXT_PUBLIC_D1_API_URL || \"https://ai-engine-1.onrender.com\";\n    const response = await fetch(\"\".concat(D1_URL, \"/api/parse-query\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            query\n        })\n    });\n    return await response.json();\n};\nconst executeSQL = async (sql)=>{\n    const D2_URL = process.env.NEXT_PUBLIC_D2_API_URL || \"http://31.220.72.148:3001\";\n    const response = await fetch(\"\".concat(D2_URL, \"/api/execute-sql\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            sql\n        })\n    });\n    return await response.json();\n};\n// Mock data for fallback\nconst getMockResponse = (message)=>{\n    return {\n        id: Date.now(),\n        sender: \"bot\",\n        text: \"Sample chart for fallback\",\n        type: \"chart\",\n        data: {\n            type: \"bar\",\n            data: {\n                labels: [\n                    \"2019\",\n                    \"2020\",\n                    \"2021\"\n                ],\n                datasets: [\n                    {\n                        label: \"Rainfall\",\n                        data: [\n                            100,\n                            200,\n                            150\n                        ],\n                        backgroundColor: \"rgba(75,192,192,0.6)\"\n                    }\n                ]\n            },\n            options: {}\n        }\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGkvYm90U2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsa0VBQWtFO0FBQzNELE1BQU1BLGlCQUFpQixPQUFPQztJQUNuQyxNQUFNQyxTQUFTQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLHNCQUFzQixJQUFJO0lBQ3JELE1BQU1DLFNBQVNILE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0csc0JBQXNCLElBQUk7SUFFckQsSUFBSTtRQUNGLHNCQUFzQjtRQUN0QixNQUFNQyxhQUFhLE1BQU1DLFdBQVdSO1FBQ3BDUyxRQUFRQyxHQUFHLENBQUMsZ0JBQWdCSDtRQUU1QixrQkFBa0I7UUFDbEIsTUFBTUksaUJBQWlCLE1BQU1DLFdBQVdMLFdBQVdNLEdBQUc7UUFDdERKLFFBQVFDLEdBQUcsQ0FBQyxxQkFBcUJDO1FBRWpDLDZDQUE2QztRQUM3QyxJQUFJRyxVQUFVO1FBQ2QsSUFBSTtZQUFDO1lBQVM7U0FBTSxDQUFDQyxRQUFRLENBQUNSLFdBQVdTLE1BQU0sR0FBRztZQUNoREYsVUFBVUcsY0FBY04sZUFBZU8sSUFBSSxFQUFFWCxXQUFXUyxNQUFNO1lBQzlEUCxRQUFRQyxHQUFHLENBQUMsdUJBQXVCSTtRQUNyQztRQUVBLHVCQUF1QjtRQUN2QixPQUFPO1lBQ0xLLElBQUlDLEtBQUtDLEdBQUc7WUFDWkMsUUFBUTtZQUNSQyxNQUFNLGVBQXlDaEIsT0FBMUJBLFdBQVdTLE1BQU0sRUFBQyxVQUF5QixPQUFqQlQsV0FBV2lCLEtBQUssRUFBQztZQUNoRUMsTUFBTWxCLFdBQVdTLE1BQU07WUFDdkJFLE1BQU1KO1lBQ05ZLFNBQVNmLGVBQWVPLElBQUksQ0FBQyxhQUFhO1FBQzVDO0lBRUYsRUFBRSxPQUFPUyxLQUFLO1FBQ1psQixRQUFRbUIsS0FBSyxDQUFDLHVCQUF1QkQ7UUFDckMsT0FBT0UsZ0JBQWdCN0I7SUFDekI7QUFDRixFQUFFO0FBRUYsc0RBQXNEO0FBQ3RELE1BQU1pQixnQkFBZ0IsQ0FBQ0MsTUFBYUY7SUFDbEMsSUFBSSxDQUFDRSxRQUFRQSxLQUFLWSxNQUFNLEtBQUssR0FBRyxPQUFPO0lBRXZDLGdDQUFnQztJQUNoQyxJQUFJQyxZQUFZO0lBQ2hCLElBQUlmLE9BQU9ELFFBQVEsQ0FBQyxRQUFRZ0IsWUFBWTtTQUNuQyxJQUFJZixPQUFPRCxRQUFRLENBQUMsUUFBUWdCLFlBQVk7U0FDeEMsSUFBSWYsT0FBT0QsUUFBUSxDQUFDLFVBQVVDLE9BQU9ELFFBQVEsQ0FBQyxZQUFZZ0IsWUFBWTtTQUN0RSxJQUFJZixPQUFPRCxRQUFRLENBQUMsV0FBV0MsT0FBT0QsUUFBUSxDQUFDLFVBQVVnQixZQUFZO0lBRTFFLGdEQUFnRDtJQUNoRCxNQUFNQyxTQUFTZCxLQUFLZSxHQUFHLENBQUNDLENBQUFBLE1BQU9BLElBQUlDLElBQUksSUFBSUQsSUFBSUUsUUFBUSxJQUFJO0lBQzNELE1BQU1DLE9BQU9DLE9BQU9ELElBQUksQ0FBQ25CLElBQUksQ0FBQyxFQUFFLEVBQUVxQixNQUFNLENBQUNDLENBQUFBLElBQUtBLE1BQU0sVUFBVUEsTUFBTTtJQUVwRSxNQUFNQyxXQUFXSixLQUFLSixHQUFHLENBQUNPLENBQUFBLElBQU07WUFDOUJFLE9BQU9GO1lBQ1B0QixNQUFNQSxLQUFLZSxHQUFHLENBQUNDLENBQUFBLE1BQU9TLE9BQU9ULEdBQUcsQ0FBQ00sRUFBRSxLQUFLO1lBQ3hDSSxpQkFBaUJiLGNBQWMsUUFDM0I7Z0JBQ0U7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDRCxHQUNEO1lBQ0pjLGFBQWE7WUFDYkMsTUFBTWYsY0FBYztRQUN0QjtJQUVBLE9BQU87UUFDTE4sTUFBTU07UUFDTmIsTUFBTTtZQUFFYztZQUFRUztRQUFTO1FBQ3pCTSxTQUFTO1lBQ1BDLFlBQVk7WUFDWkMsU0FBUztnQkFDUEMsUUFBUTtvQkFBRUMsVUFBVTtnQkFBTTtnQkFDMUJDLE9BQU87b0JBQUVDLFNBQVM7b0JBQU05QixNQUFNO2dCQUFpQztZQUNqRTtRQUNGO0lBQ0Y7QUFDRjtBQUVBLDJDQUEyQztBQUNwQyxNQUFNZixhQUFhLE9BQU9nQjtJQUMvQixNQUFNdkIsU0FBU0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxzQkFBc0IsSUFBSTtJQUNyRCxNQUFNa0QsV0FBVyxNQUFNQyxNQUFNLEdBQVUsT0FBUHRELFFBQU8scUJBQW1CO1FBQ3hEdUQsUUFBUTtRQUNSQyxTQUFTO1lBQUUsZ0JBQWdCO1FBQW1CO1FBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7WUFBRXBDO1FBQU07SUFDL0I7SUFDQSxPQUFPLE1BQU04QixTQUFTTyxJQUFJO0FBQzVCLEVBQUU7QUFFSyxNQUFNakQsYUFBYSxPQUFPQztJQUMvQixNQUFNUixTQUFTSCxPQUFPQSxDQUFDQyxHQUFHLENBQUNHLHNCQUFzQixJQUFJO0lBQ3JELE1BQU1nRCxXQUFXLE1BQU1DLE1BQU0sR0FBVSxPQUFQbEQsUUFBTyxxQkFBbUI7UUFDeERtRCxRQUFRO1FBQ1JDLFNBQVM7WUFBRSxnQkFBZ0I7UUFBbUI7UUFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztZQUFFL0M7UUFBSTtJQUM3QjtJQUNBLE9BQU8sTUFBTXlDLFNBQVNPLElBQUk7QUFDNUIsRUFBRTtBQUVGLHlCQUF5QjtBQUN6QixNQUFNaEMsa0JBQWtCLENBQUM3QjtJQUN2QixPQUFPO1FBQ0xtQixJQUFJQyxLQUFLQyxHQUFHO1FBQ1pDLFFBQVE7UUFDUkMsTUFBTTtRQUNORSxNQUFNO1FBQ05QLE1BQU07WUFDSk8sTUFBTTtZQUNOUCxNQUFNO2dCQUNKYyxRQUFRO29CQUFDO29CQUFRO29CQUFRO2lCQUFPO2dCQUNoQ1MsVUFBVTtvQkFDUjt3QkFBRUMsT0FBTzt3QkFBWXhCLE1BQU07NEJBQUM7NEJBQUs7NEJBQUs7eUJBQUk7d0JBQUUwQixpQkFBaUI7b0JBQXVCO2lCQUNyRjtZQUNIO1lBQ0FHLFNBQVMsQ0FBQztRQUNaO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYXBpL2JvdFNlcnZpY2UudHM/ZmI1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBCb3Qgc2VydmljZSBmb3IgaGFuZGxpbmcgQUkgcmVzcG9uc2VzIHdpdGggbXVsdGlwbGUgY2hhcnQgdHlwZXNcclxuZXhwb3J0IGNvbnN0IGdldEJvdFJlc3BvbnNlID0gYXN5bmMgKG1lc3NhZ2U6IHN0cmluZykgPT4ge1xyXG4gIGNvbnN0IEQxX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0QxX0FQSV9VUkwgfHwgXCJodHRwczovL2FpLWVuZ2luZS0xLm9ucmVuZGVyLmNvbVwiO1xyXG4gIGNvbnN0IEQyX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0QyX0FQSV9VUkwgfHwgXCJodHRwOi8vMzEuMjIwLjcyLjE0ODozMDAxXCI7XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBTdGVwIDE6IFBhcnNlIHF1ZXJ5XHJcbiAgICBjb25zdCBkMVJlc3BvbnNlID0gYXdhaXQgcGFyc2VRdWVyeShtZXNzYWdlKTtcclxuICAgIGNvbnNvbGUubG9nKFwiRDEgUmVzcG9uc2U6XCIsIGQxUmVzcG9uc2UpO1xyXG5cclxuICAgIC8vIFN0ZXAgMjogUnVuIFNRTFxyXG4gICAgY29uc3QgZDJEYXRhUmVzcG9uc2UgPSBhd2FpdCBleGVjdXRlU1FMKGQxUmVzcG9uc2Uuc3FsKTtcclxuICAgIGNvbnNvbGUubG9nKFwiRDIgRGF0YSBSZXNwb25zZTpcIiwgZDJEYXRhUmVzcG9uc2UpO1xyXG5cclxuICAgIC8vIFN0ZXAgMzogRm9ybWF0IGRhdGEgZm9yIGNoYXJ0cy9tYXBzL3RhYmxlc1xyXG4gICAgbGV0IHZpekRhdGEgPSBudWxsO1xyXG4gICAgaWYgKFtcImNoYXJ0XCIsIFwibWFwXCJdLmluY2x1ZGVzKGQxUmVzcG9uc2UuaW50ZW50KSkge1xyXG4gICAgICB2aXpEYXRhID0gZm9ybWF0Vml6RGF0YShkMkRhdGFSZXNwb25zZS5kYXRhLCBkMVJlc3BvbnNlLmludGVudCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiRm9ybWF0dGVkIFZpeiBEYXRhOlwiLCB2aXpEYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGVwIDQ6IFJldHVybiB0byBVSVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6IERhdGUubm93KCksXHJcbiAgICAgIHNlbmRlcjogXCJib3RcIixcclxuICAgICAgdGV4dDogYEhlcmUgaXMgdGhlICR7ZDFSZXNwb25zZS5pbnRlbnR9IGZvciBcIiR7ZDFSZXNwb25zZS5xdWVyeX1cImAsXHJcbiAgICAgIHR5cGU6IGQxUmVzcG9uc2UuaW50ZW50LFxyXG4gICAgICBkYXRhOiB2aXpEYXRhLFxyXG4gICAgICByYXdEYXRhOiBkMkRhdGFSZXNwb25zZS5kYXRhIC8vIGZvciB0YWJsZXNcclxuICAgIH07XHJcblxyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkJvdCByZXNwb25zZSBlcnJvcjpcIiwgZXJyKTtcclxuICAgIHJldHVybiBnZXRNb2NrUmVzcG9uc2UobWVzc2FnZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gLS0tLS0tLS0tLSBGb3JtYXQgQ2hhcnQgRGF0YSBEeW5hbWljYWxseSAtLS0tLS0tLS0tXHJcbmNvbnN0IGZvcm1hdFZpekRhdGEgPSAoZGF0YTogYW55W10sIGludGVudDogc3RyaW5nKSA9PiB7XHJcbiAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgLy8gRGV0ZWN0IGNoYXJ0IHR5cGUgZnJvbSBpbnRlbnRcclxuICBsZXQgY2hhcnRUeXBlID0gXCJsaW5lXCI7XHJcbiAgaWYgKGludGVudC5pbmNsdWRlcyhcImJhclwiKSkgY2hhcnRUeXBlID0gXCJiYXJcIjtcclxuICBlbHNlIGlmIChpbnRlbnQuaW5jbHVkZXMoXCJwaWVcIikpIGNoYXJ0VHlwZSA9IFwicGllXCI7XHJcbiAgZWxzZSBpZiAoaW50ZW50LmluY2x1ZGVzKFwibWFwXCIpIHx8IGludGVudC5pbmNsdWRlcyhcImhlYXRtYXBcIikpIGNoYXJ0VHlwZSA9IFwiaGVhdG1hcFwiO1xyXG4gIGVsc2UgaWYgKGludGVudC5pbmNsdWRlcyhcImxpbmVcIikgfHwgaW50ZW50LmluY2x1ZGVzKFwidHJlbmRcIikpIGNoYXJ0VHlwZSA9IFwibGluZVwiO1xyXG5cclxuICAvLyBFeHRyYWN0IGxhYmVscyAoeC1heGlzKSAmIGRhdGFzZXRzICh5LXZhbHVlcylcclxuICBjb25zdCBsYWJlbHMgPSBkYXRhLm1hcChyb3cgPT4gcm93LnllYXIgfHwgcm93LmNhdGVnb3J5IHx8IFwiVW5rbm93blwiKTtcclxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YVswXSkuZmlsdGVyKGsgPT4gayAhPT0gXCJ5ZWFyXCIgJiYgayAhPT0gXCJjYXRlZ29yeVwiKTtcclxuXHJcbiAgY29uc3QgZGF0YXNldHMgPSBrZXlzLm1hcChrID0+ICh7XHJcbiAgICBsYWJlbDogayxcclxuICAgIGRhdGE6IGRhdGEubWFwKHJvdyA9PiBOdW1iZXIocm93W2tdKSB8fCAwKSxcclxuICAgIGJhY2tncm91bmRDb2xvcjogY2hhcnRUeXBlID09PSBcInBpZVwiXHJcbiAgICAgID8gW1xyXG4gICAgICAgICAgXCJyZ2JhKDI1NSw5OSwxMzIsMC42KVwiLFxyXG4gICAgICAgICAgXCJyZ2JhKDU0LDE2MiwyMzUsMC42KVwiLFxyXG4gICAgICAgICAgXCJyZ2JhKDI1NSwyMDYsODYsMC42KVwiLFxyXG4gICAgICAgICAgXCJyZ2JhKDc1LDE5MiwxOTIsMC42KVwiXHJcbiAgICAgICAgXVxyXG4gICAgICA6IFwicmdiYSg1NCwxNjIsMjM1LDAuNSlcIixcclxuICAgIGJvcmRlckNvbG9yOiBcInJnYmEoNTQsMTYyLDIzNSwxKVwiLFxyXG4gICAgZmlsbDogY2hhcnRUeXBlICE9PSBcImxpbmVcIlxyXG4gIH0pKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IGNoYXJ0VHlwZSxcclxuICAgIGRhdGE6IHsgbGFiZWxzLCBkYXRhc2V0cyB9LFxyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4gICAgICBwbHVnaW5zOiB7XHJcbiAgICAgICAgbGVnZW5kOiB7IHBvc2l0aW9uOiBcInRvcFwiIH0sXHJcbiAgICAgICAgdGl0bGU6IHsgZGlzcGxheTogdHJ1ZSwgdGV4dDogXCJHcm91bmR3YXRlciBEYXRhIFZpc3VhbGl6YXRpb25cIiB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59O1xyXG5cclxuLy8gLS0tLS0tLS0tLSBFeGlzdGluZyBGdW5jdGlvbnMgLS0tLS0tLS0tLVxyXG5leHBvcnQgY29uc3QgcGFyc2VRdWVyeSA9IGFzeW5jIChxdWVyeTogc3RyaW5nKSA9PiB7XHJcbiAgY29uc3QgRDFfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRDFfQVBJX1VSTCB8fCBcImh0dHBzOi8vYWktZW5naW5lLTEub25yZW5kZXIuY29tXCI7XHJcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtEMV9VUkx9L2FwaS9wYXJzZS1xdWVyeWAsIHtcclxuICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXHJcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHF1ZXJ5IH0pXHJcbiAgfSk7XHJcbiAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBleGVjdXRlU1FMID0gYXN5bmMgKHNxbDogc3RyaW5nKSA9PiB7XHJcbiAgY29uc3QgRDJfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRDJfQVBJX1VSTCB8fCBcImh0dHA6Ly8zMS4yMjAuNzIuMTQ4OjMwMDFcIjtcclxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0QyX1VSTH0vYXBpL2V4ZWN1dGUtc3FsYCwge1xyXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcclxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgc3FsIH0pXHJcbiAgfSk7XHJcbiAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxufTtcclxuXHJcbi8vIE1vY2sgZGF0YSBmb3IgZmFsbGJhY2tcclxuY29uc3QgZ2V0TW9ja1Jlc3BvbnNlID0gKG1lc3NhZ2U6IHN0cmluZykgPT4ge1xyXG4gIHJldHVybiB7XHJcbiAgICBpZDogRGF0ZS5ub3coKSxcclxuICAgIHNlbmRlcjogXCJib3RcIixcclxuICAgIHRleHQ6IFwiU2FtcGxlIGNoYXJ0IGZvciBmYWxsYmFja1wiLFxyXG4gICAgdHlwZTogXCJjaGFydFwiLFxyXG4gICAgZGF0YToge1xyXG4gICAgICB0eXBlOiBcImJhclwiLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgbGFiZWxzOiBbXCIyMDE5XCIsIFwiMjAyMFwiLCBcIjIwMjFcIl0sXHJcbiAgICAgICAgZGF0YXNldHM6IFtcclxuICAgICAgICAgIHsgbGFiZWw6IFwiUmFpbmZhbGxcIiwgZGF0YTogWzEwMCwgMjAwLCAxNTBdLCBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg3NSwxOTIsMTkyLDAuNilcIiB9XHJcbiAgICAgICAgXVxyXG4gICAgICB9LFxyXG4gICAgICBvcHRpb25zOiB7fVxyXG4gICAgfVxyXG4gIH07XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJnZXRCb3RSZXNwb25zZSIsIm1lc3NhZ2UiLCJEMV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfRDFfQVBJX1VSTCIsIkQyX1VSTCIsIk5FWFRfUFVCTElDX0QyX0FQSV9VUkwiLCJkMVJlc3BvbnNlIiwicGFyc2VRdWVyeSIsImNvbnNvbGUiLCJsb2ciLCJkMkRhdGFSZXNwb25zZSIsImV4ZWN1dGVTUUwiLCJzcWwiLCJ2aXpEYXRhIiwiaW5jbHVkZXMiLCJpbnRlbnQiLCJmb3JtYXRWaXpEYXRhIiwiZGF0YSIsImlkIiwiRGF0ZSIsIm5vdyIsInNlbmRlciIsInRleHQiLCJxdWVyeSIsInR5cGUiLCJyYXdEYXRhIiwiZXJyIiwiZXJyb3IiLCJnZXRNb2NrUmVzcG9uc2UiLCJsZW5ndGgiLCJjaGFydFR5cGUiLCJsYWJlbHMiLCJtYXAiLCJyb3ciLCJ5ZWFyIiwiY2F0ZWdvcnkiLCJrZXlzIiwiT2JqZWN0IiwiZmlsdGVyIiwiayIsImRhdGFzZXRzIiwibGFiZWwiLCJOdW1iZXIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsImZpbGwiLCJvcHRpb25zIiwicmVzcG9uc2l2ZSIsInBsdWdpbnMiLCJsZWdlbmQiLCJwb3NpdGlvbiIsInRpdGxlIiwiZGlzcGxheSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJqc29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api/botService.ts\n"));

/***/ })

});